import { GoogleGenAI } from "@google/genai";
import { convertToEvaluationResponse, EvaluationApiResponse } from "./evaluation-response.utils";
import { config } from "../configs/config";
import fs from 'fs';
import path from "path";
import { EvaluationType } from "../types/enums";
import { getBasePrompt, getResponseType } from "./evaluation.helper";

const ai = new GoogleGenAI({
  apiKey: config.gemini.apiKey || 'AIzaSyBsXss656hnvhlLtKpLoWWIEc0vf-TDzic',
});

interface FileData {
  label: string;
  fileUrl: string;
  mimeType?: string;
}

export async function evaluationWithGemini(
  fileUrl: string, 
  evaluationType: EvaluationType = EvaluationType.QPA,
  additionalFiles?: FileData[]
): Promise<EvaluationApiResponse | null> {
  try {
    console.log(`Starting evaluation for type: ${evaluationType}`);
    
    // Prepare all files for upload
    const filesToUpload: FileData[] = [
      { label: evaluationType.split('_')[0], fileUrl, mimeType: 'application/pdf' }
    ];
    
    if (additionalFiles) {
      filesToUpload.push(...additionalFiles);
    }

    // Upload all files to Gemini
    const uploadedFiles = await Promise.all(
      filesToUpload.map(async (fileData) => {
        const answerFile = await fetch(fileData.fileUrl);
        const answerBlob = await answerFile.blob();
        
        const uploaded = await ai.files.upload({ 
          file: answerBlob
        });
        
        return {
          label: fileData.label,
          uri: uploaded.uri,
          mimeType: uploaded.mimeType,
        };
      })
    );

    console.log(`Uploaded ${uploadedFiles.length} files to Gemini`);

    // Prepare the prompt using helper functions
    const basePrompt = getBasePrompt(evaluationType);
    const responseType = getResponseType();
    
    const prompt = `${basePrompt}.
    
    - You are given the following files for evaluation:
      ${uploadedFiles.map(file => `- ${file.label} file: refer to it as "${file.label}" in your evaluation.`).join('\n')}

    ${responseType}
    `;

    // Prepare contents for Gemini
    const model = 'gemini-2.0-flash';
    const contents = [
      {
        role: "user",
        parts: [
          ...uploadedFiles.map((file) => ({
            fileData: {
              fileUri: file.uri,
              mimeType: file.mimeType,
            }
          })),
          {
            text: prompt,
          },
        ],
      },
    ];

    console.log("Sending request to Gemini...");
    const response = await ai.models.generateContent({
      model,
      contents
    });

    console.log("Received response from Gemini");

    // Save raw response to public/evaluations
    const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
    const filename = `evaluation-${evaluationType}-${timestamp}.txt`;
    const responseFileName = `response-${evaluationType}-${timestamp}.json`;
    const dir = path.join(process.cwd(), 'public', 'evaluations');
    if (!fs.existsSync(dir)) {
      fs.mkdirSync(dir, { recursive: true });
    }
    const filePath = path.join(dir, "raw-response-" + filename);
    const responseFilePath = path.join(dir, responseFileName);
    fs.writeFileSync(filePath, JSON.stringify(response, null, 2));

    // Parse Gemini response
    const responseText = response.candidates?.[0]?.content?.parts?.[0]?.text;
    if (!responseText) throw new Error("No response text received from Gemini API");

    // Convert the response using our utility function
    const evaluationData = convertToEvaluationResponse(responseText);
    const finalResponse = {
      ...evaluationData,
      metadata: {
        tokensUsed: response.usageMetadata?.totalTokenCount || 0,
        model: model,
        fileUrl: fileUrl,
        evaluationType: evaluationType,
        additionalFiles: additionalFiles || [],
      }
    }

    // Save the parsed response
    fs.writeFileSync(responseFilePath, JSON.stringify(finalResponse, null, 2));

    console.log("Evaluation completed successfully");
    return finalResponse;

  } catch (error) {
    console.error("Evaluation failed:", error);
    return null;
  }
}

// Legacy function for backward compatibility
export async function evaluationWithGeminiLegacy(url: string): Promise<EvaluationApiResponse | null> {
  return evaluationWithGemini(url, EvaluationType.QPA);
}

